# 防作弊

游戏内存存在一些值，例如HP,MP,力量,智力等都是可以利用内存搜索器搜索到，并且很多网络游戏的伤害计算都是在客户端进行，因此对敏感字段要进行加密操作。

### 敏感字段内存加密

内存修改器的原理是搜索变化值，因此为了防止变化字段被搜索，采用如下的算法。

1. 生成随机数，作为密钥，并且密钥的每一位不能相同，长度为当前加密字段的内存长度。
2. 加密，使用当前生成的密钥进行**异或操作**，解密的时候在进行一次**异或操作**即可还原该数值。
   
以下为对应的加密算法
   
``` cpp
T value;
int8_t keyBytes[sizeof(T)];
auto generateRandBytes() -> void
{
    for (int8_t i = 0; i < sizeof(T); i++)
    {
        keyBytes[i] = rand.nextInt(0, 127);
        while (i > 0 && keyBytes[i] == keyBytes[i - 1]) {
            keyBytes[i] = rand.nextInt(0, 127);
        }
    }
    int8_t index = 0;
    //if all number are the same,the user must use cheat engine;
    for (int8_t i = 0; i < sizeof(T); i++)
    {
        if (keyBytes[i] == keyBytes[0]) 
        {
            index++;
        }
    }
    if (index == sizeof(T))
    {
        LogW("CheatEngine for Ban Random");
    }
}

auto encrypt(const T &t) -> void
{
    auto size = sizeof(T);
    value = t;
    uint8_t *bytes = (uint8_t *)&value;
    for (int8_t i = 0; i < size; i++)
    {
        bytes[i] ^= keyBytes[i];
    }
}

auto getValue() -> T
{
    T t2 = value;
    uint8_t *bytes = (uint8_t *)&t2;
    for (int8_t i = 0; i < sizeof(T); i++)
    {
        bytes[i] ^= keyBytes[i];
    }
    return t2;
}

```

